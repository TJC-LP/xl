# P6.8: Surgical Modification & Passthrough Architecture

**Status**: üü° Design Complete, Ready for Implementation
**Priority**: HIGHEST (Foundation for all future OOXML features)
**Estimated Effort**: 8-10 days (6 phases)
**Complexity**: MEDIUM-HIGH
**Design Date**: 2025-11-16

---

## Executive Summary

This design establishes XL's foundational architecture for **surgical modification**: the ability to read an Excel file, modify specific cells/sheets, and write it back while **preserving ALL other content** (charts, images, comments, pivot tables, etc.) even if XL doesn't understand those features.

**Key Insight**: No other Excel library supports true surgical modification. Apache POI, OpenXML SDK, and others either:
1. Lose unknown features on round-trip (most libraries)
2. Require full parsing of all features (memory intensive)
3. Can't distinguish "not modified" from "deleted"

XL will be **the first library** to support true minimal-touch semantics: "Modify cell A1, preserve everything else."

**Value Proposition**:
- üéØ **Zero data loss**: Charts, images, comments preserved automatically
- üöÄ **2-11x faster writes**: Only regenerate modified parts
- üíæ **Memory efficient**: Don't load/parse unknown parts
- ‚úÖ **Backwards compatible**: Existing code works unchanged
- üîÆ **Future proof**: Foundation for incremental OOXML feature additions

---

## Problem Statement

### Current Behavior (Lossy Round-Trips)

```scala
// User scenario: Update cell A1 in existing file with charts
val workbook = ExcelIO.instance.read[IO](existingFileWithCharts)
val updated = workbook.flatMap { wb =>
  wb("Sales").flatMap { sheet =>
    sheet.put(cell"A1", "Updated Value")
  }
}
ExcelIO.instance.write[IO](updated, outputPath)

// ‚ùå PROBLEM: Charts are LOST in output file!
// Reason: XlsxReader only processes 7 parts, discards xl/charts/
```

**Root Cause**: XL uses "parse ‚Üí transform ‚Üí regenerate from scratch" architecture:

```scala
// XlsxReader.scala (current)
def readFromStream(is: InputStream): XLResult[Workbook] =
  val parts = extractKnownParts(zip)  // Only 7 specific paths
  parseWorkbook(parts)                // Unknown parts discarded

// XlsxWriter.scala (current)
def writeZip(workbook: Workbook, ...): Unit =
  // Regenerates ALL parts from domain model
  writePart(zip, "xl/workbook.xml", ...)
  writePart(zip, "xl/worksheets/sheet1.xml", ...)
  // Charts/images/comments never existed in domain model ‚Üí lost
```

### Requirements

**MUST HAVE** (P6.8 Core):
1. Preserve unknown ZIP entries across read ‚Üí modify ‚Üí write cycles
2. Track which sheets were modified (dirty tracking)
3. Only regenerate modified sheets' XML
4. Copy unmodified sheets and unknown parts verbatim
5. Handle relationships correctly (don't break rId references)
6. Memory efficient (don't materialize unknown parts)
7. Deterministic output (modified cells get canonical XML)
8. Non-breaking API changes (existing code works)

**NICE TO HAVE** (P6.8 Stretch):
9. Lazy loading of preserved parts (stream from disk)
10. Validation warnings (e.g., "sheet references deleted chart")
11. Streaming compatibility detection
12. Performance metrics (preserved vs. regenerated bytes)

**FUTURE WORK** (P7-P11):
13. Parse and modify specific features (comments, hyperlinks, etc.)
14. Add new features programmatically (create charts via API)
15. Cross-workbook reference tracking
16. Formula dependency analysis

---

## Architecture Overview

### High-Level Design

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     XL Domain Model                         ‚îÇ
‚îÇ  (Pure, Immutable, Type-Safe)                              ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  Workbook(sheets, metadata, sourceContext)                 ‚îÇ
‚îÇ      ‚îÇ                                                      ‚îÇ
‚îÇ      ‚îú‚îÄ sheets: Vector[Sheet]  ‚Üê Modified by user          ‚îÇ
‚îÇ      ‚îú‚îÄ metadata: WorkbookMetadata                         ‚îÇ
‚îÇ      ‚îî‚îÄ sourceContext: Option[SourceContext]               ‚îÇ
‚îÇ             ‚îÇ                                               ‚îÇ
‚îÇ             ‚îú‚îÄ sourcePath: Path                            ‚îÇ
‚îÇ             ‚îú‚îÄ modificationTracker: ModificationTracker    ‚îÇ
‚îÇ             ‚îî‚îÄ preservedParts: LazyPreservedParts          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚ñ≤                    ‚îÇ
                         ‚îÇ read               ‚îÇ write
                         ‚îÇ                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      XlsxReader                   ‚îÇ  ‚îÇ   XlsxWriter        ‚îÇ
‚îÇ  (Enhanced with Passthrough)      ‚îÇ  ‚îÇ  (Hybrid Strategy)  ‚îÇ
‚îÇ                                    ‚îÇ  ‚îÇ                     ‚îÇ
‚îÇ  1. Extract all ZIP entries       ‚îÇ  ‚îÇ  if (unmodified)    ‚îÇ
‚îÇ  2. Parse known parts ‚Üí Model     ‚îÇ  ‚îÇ    ‚Üí copy source    ‚îÇ
‚îÇ  3. Index unknown parts           ‚îÇ  ‚îÇ  else               ‚îÇ
‚îÇ  4. Create SourceContext          ‚îÇ  ‚îÇ    ‚Üí regenerate XML ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚ñ≤                    ‚îÇ
                         ‚îÇ                    ‚ñº
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ     Physical XLSX File       ‚îÇ
                    ‚îÇ  (ZIP with 30+ XML parts)    ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Core Concepts

**1. SourceContext**: Tracks original file and modifications

```scala
case class SourceContext(
  sourcePath: Path,                           // Original file location
  modificationTracker: ModificationTracker,   // What changed
  preservedParts: LazyPreservedParts          // Unknown parts index
)
```

**2. ModificationTracker**: Immutable tracking of changes

```scala
case class ModificationTracker(
  modifiedSheets: Set[Int],           // Sheet indices changed
  deletedSheets: Set[Int],            // Sheet indices removed
  reorderedSheets: Boolean,           // Sheet order changed
  modifiedMetadata: Boolean           // Workbook-level changes
)
```

**3. LazyPreservedParts**: Efficient access to unknown parts

```scala
trait LazyPreservedParts:
  def exists(path: String): Boolean
  def copyTo(path: String, zip: ZipOutputStream): IO[Unit]
  def listAll: Set[String]
```

**4. Hybrid Write Strategy**: Regenerate only what changed

```scala
def writeZip(workbook: Workbook, output: Path): IO[Unit] =
  workbook.sourceContext match
    case None =>
      // No source, full regeneration (current behavior)
      regenerateAll(workbook, output)

    case Some(ctx) if ctx.modificationTracker.isClean =>
      // Nothing changed, just copy file
      Files.copy(ctx.sourcePath, output)

    case Some(ctx) =>
      // Hybrid: regenerate modified, copy preserved
      hybridWrite(workbook, ctx, output)
```

---

## Domain Model Changes

### 1. Workbook Enhancement

**Location**: `xl-core/src/com/tjclp/xl/sheet.scala`

```scala
// BEFORE
case class Workbook(
  sheets: Vector[Sheet],
  metadata: WorkbookMetadata,
  activeSheetIndex: Int
)

// AFTER (with SourceContext)
case class Workbook(
  sheets: Vector[Sheet],
  metadata: WorkbookMetadata,
  activeSheetIndex: Int,
  sourceContext: Option[SourceContext] = None  // NEW: Track original
)

object Workbook:
  /** Create fresh workbook (no source) */
  def empty: Workbook = Workbook(Vector.empty, WorkbookMetadata.default, 0, None)

  /** Create from existing file (with source tracking) */
  def fromFile(path: Path, sheets: Vector[Sheet], metadata: WorkbookMetadata): Workbook =
    val tracker = ModificationTracker.clean
    val preserved = LazyPreservedParts.fromFile(path)
    val context = SourceContext(path, tracker, preserved)
    Workbook(sheets, metadata, 0, Some(context))
```

**Invariants**:
- `sourceContext.isDefined` ‚ü∫ workbook was read from file
- `sourceContext.isEmpty` ‚ü∫ workbook created programmatically
- `sheets.indices` must match `modificationTracker` indices

---

### 2. SourceContext (New Type)

**Location**: `xl-core/src/com/tjclp/xl/SourceContext.scala` (new file)

```scala
package com.tjclp.xl

import java.nio.file.Path
import cats.effect.IO

/**
 * Tracks the source file and modifications for surgical write operations.
 *
 * INVARIANTS:
 * - sourcePath must exist when SourceContext is created
 * - preservedParts must reference valid ZIP entries in sourcePath
 * - modificationTracker accurately reflects all domain model changes
 *
 * PURITY: This is a pure data structure. File I/O happens lazily via preservedParts.
 */
case class SourceContext(
  sourcePath: Path,
  modificationTracker: ModificationTracker,
  preservedParts: LazyPreservedParts
):
  /** Check if workbook has no modifications (can skip write) */
  def isClean: Boolean = modificationTracker.isClean

  /** Mark a sheet as modified */
  def markSheetModified(sheetIndex: Int): SourceContext =
    copy(modificationTracker = modificationTracker.markSheet(sheetIndex))

  /** Mark a sheet as deleted */
  def markSheetDeleted(sheetIndex: Int): SourceContext =
    copy(modificationTracker = modificationTracker.deleteSheet(sheetIndex))

  /** Mark sheets as reordered */
  def markReordered: SourceContext =
    copy(modificationTracker = modificationTracker.markReordered)

  /** Mark metadata as changed */
  def markMetadataModified: SourceContext =
    copy(modificationTracker = modificationTracker.markMetadata)

object SourceContext:
  /** Create from file path (called by XlsxReader) */
  def fromFile(
    path: Path,
    allEntries: Set[String],
    knownParts: Set[String]
  ): SourceContext =
    val unknownParts = allEntries -- knownParts
    val preserved = LazyPreservedParts.fromPath(path, unknownParts)
    SourceContext(path, ModificationTracker.clean, preserved)
```

---

### 3. ModificationTracker (New Type)

**Location**: `xl-core/src/com/tjclp/xl/ModificationTracker.scala` (new file)

```scala
package com.tjclp.xl

/**
 * Immutable tracker for workbook modifications.
 *
 * LAWS:
 * - Monotonicity: Once modified, always modified (no "undo" tracking)
 * - Composition: Trackers compose via merging modified sets
 * - Clean state: Default tracker indicates no modifications
 */
case class ModificationTracker(
  modifiedSheets: Set[Int] = Set.empty,
  deletedSheets: Set[Int] = Set.empty,
  reorderedSheets: Boolean = false,
  modifiedMetadata: Boolean = false
):
  /** Check if no modifications */
  def isClean: Boolean =
    modifiedSheets.isEmpty &&
    deletedSheets.isEmpty &&
    !reorderedSheets &&
    !modifiedMetadata

  /** Mark sheet as modified */
  def markSheet(index: Int): ModificationTracker =
    copy(modifiedSheets = modifiedSheets + index)

  /** Mark multiple sheets as modified */
  def markSheets(indices: Set[Int]): ModificationTracker =
    copy(modifiedSheets = modifiedSheets ++ indices)

  /** Mark sheet as deleted */
  def deleteSheet(index: Int): ModificationTracker =
    copy(
      deletedSheets = deletedSheets + index,
      modifiedSheets = modifiedSheets - index  // Can't be both
    )

  /** Mark sheets as reordered */
  def markReordered: ModificationTracker =
    copy(reorderedSheets = true)

  /** Mark workbook metadata as modified */
  def markMetadata: ModificationTracker =
    copy(modifiedMetadata = true)

  /** Merge two trackers (for composing modifications) */
  def merge(other: ModificationTracker): ModificationTracker =
    ModificationTracker(
      modifiedSheets = modifiedSheets ++ other.modifiedSheets,
      deletedSheets = deletedSheets ++ other.deletedSheets,
      reorderedSheets = reorderedSheets || other.reorderedSheets,
      modifiedMetadata = modifiedMetadata || other.modifiedMetadata
    )

object ModificationTracker:
  /** Clean tracker (no modifications) */
  val clean: ModificationTracker = ModificationTracker()

  /** Create tracker with all sheets marked modified */
  def allModified(sheetCount: Int): ModificationTracker =
    ModificationTracker(modifiedSheets = (0 until sheetCount).toSet)
```

---

### 4. LazyPreservedParts (New Trait)

**Location**: `xl-ooxml/src/com/tjclp/xl/ooxml/LazyPreservedParts.scala` (new file)

```scala
package com.tjclp.xl.ooxml

import java.nio.file.Path
import java.util.zip.{ZipFile, ZipOutputStream}
import cats.effect.{IO, Resource}
import scala.collection.immutable.Set

/**
 * Lazy access to preserved ZIP entries from source file.
 *
 * DESIGN: Does NOT materialize entries into memory. All operations
 * stream directly from source ZIP to destination ZIP.
 *
 * PURITY: All operations return IO (file I/O is effect).
 */
trait LazyPreservedParts:
  /** Check if part exists in preserved set */
  def exists(path: String): Boolean

  /** List all preserved part paths */
  def listAll: Set[String]

  /** Copy part directly to output ZIP (streaming) */
  def copyTo(path: String, output: ZipOutputStream): IO[Unit]

  /** Copy multiple parts to output ZIP */
  def copyAllTo(paths: Set[String], output: ZipOutputStream): IO[Unit] =
    paths.toList.traverse_(path => copyTo(path, output))

object LazyPreservedParts:
  /** Create from source file path and part names */
  def fromPath(sourcePath: Path, parts: Set[String]): LazyPreservedParts =
    new LazyPreservedPartsImpl(sourcePath, parts)

  /** Empty preserved parts (for programmatically created workbooks) */
  val empty: LazyPreservedParts = new LazyPreservedPartsImpl(null, Set.empty)

private class LazyPreservedPartsImpl(
  sourcePath: Path,
  parts: Set[String]
) extends LazyPreservedParts:

  def exists(path: String): Boolean = parts.contains(path)

  def listAll: Set[String] = parts

  def copyTo(path: String, output: ZipOutputStream): IO[Unit] =
    if !exists(path) then
      IO.raiseError(new IllegalArgumentException(s"Part not preserved: $path"))
    else
      Resource.make(IO(new ZipFile(sourcePath.toFile)))(zf => IO(zf.close())).use { zip =>
        IO {
          val entry = zip.getEntry(path)
          if entry == null then
            throw new IllegalStateException(s"Entry missing from source: $path")

          val newEntry = new java.util.zip.ZipEntry(path)
          newEntry.setTime(0)  // Deterministic timestamp

          output.putNextEntry(newEntry)
          val is = zip.getInputStream(entry)
          is.transferTo(output)
          is.close()
          output.closeEntry()
        }
      }
```

**Key Properties**:
- üíæ **Zero memory overhead**: Parts are never materialized, only indexed
- üîí **Read-only**: Source file is never modified
- üöÄ **Streaming**: `copyTo` streams bytes directly (no buffering)
- ‚úÖ **Deterministic**: Timestamp set to 0 for byte-identical output

---

### 5. Workbook Modification Helpers

**Location**: `xl-core/src/com/tjclp/xl/sheet.scala` (extensions)

```scala
extension (wb: Workbook)
  /** Update a sheet by name, tracking modification */
  def updateSheet(name: SheetName, f: Sheet => Sheet): XLResult[Workbook] =
    wb.sheets.indexWhere(_.name == name) match
      case -1 => Left(XLError.SheetNotFound(name.value))
      case idx =>
        val updated = f(wb.sheets(idx))
        val newSheets = wb.sheets.updated(idx, updated)
        val newContext = wb.sourceContext.map(_.markSheetModified(idx))
        Right(wb.copy(sheets = newSheets, sourceContext = newContext))

  /** Update a sheet by index, tracking modification */
  def updateSheetAt(idx: Int, f: Sheet => Sheet): XLResult[Workbook] =
    if idx < 0 || idx >= wb.sheets.size then
      Left(XLError.InvalidSheetIndex(idx))
    else
      val updated = f(wb.sheets(idx))
      val newSheets = wb.sheets.updated(idx, updated)
      val newContext = wb.sourceContext.map(_.markSheetModified(idx))
      Right(wb.copy(sheets = newSheets, sourceContext = newContext))

  /** Delete a sheet, tracking modification */
  def deleteSheet(name: SheetName): XLResult[Workbook] =
    wb.sheets.indexWhere(_.name == name) match
      case -1 => Left(XLError.SheetNotFound(name.value))
      case idx =>
        val newSheets = wb.sheets.patch(idx, Nil, 1)
        val newContext = wb.sourceContext.map(_.markSheetDeleted(idx))
        Right(wb.copy(sheets = newSheets, sourceContext = newContext))

  /** Reorder sheets, tracking modification */
  def reorderSheets(newOrder: Vector[SheetName]): XLResult[Workbook] =
    // Validate all sheets present
    if newOrder.toSet != wb.sheets.map(_.name).toSet then
      Left(XLError.InvalidOperation("Sheet names don't match"))
    else
      val reordered = newOrder.flatMap { name =>
        wb.sheets.find(_.name == name)
      }
      val newContext = wb.sourceContext.map(_.markReordered)
      val allModified = wb.sourceContext.map { ctx =>
        ctx.copy(modificationTracker = ctx.modificationTracker.markSheets(wb.sheets.indices.toSet))
      }
      Right(wb.copy(sheets = reordered, sourceContext = allModified))
```

**Design Notes**:
- ‚úÖ All updates return `XLResult[Workbook]` (total functions)
- ‚úÖ Modification tracking is automatic (user doesn't see it)
- ‚úÖ Immutable updates (functional style)
- ‚úÖ Type-safe sheet references

---

## Reader Enhancements

### XlsxReader Changes

**Location**: `xl-ooxml/src/com/tjclp/xl/ooxml/XlsxReader.scala`

**Changes Required**:

1. **Index all ZIP entries** (not just known 7):

```scala
// BEFORE
def readFromStream(is: InputStream): XLResult[Workbook] =
  val parts = mutable.Map[String, String]()
  val zip = new ZipInputStream(is)
  var entry = zip.getNextEntry

  while entry != null do
    if !entry.isDirectory then
      val content = new String(zip.readAllBytes(), "UTF-8")
      parts(entry.getName) = content  // Only known parts stored
    zip.closeEntry()
    entry = zip.getNextEntry

  parseWorkbook(parts.toMap)

// AFTER
def readFromStream(is: InputStream, sourcePath: Option[Path]): XLResult[Workbook] =
  val allEntries = mutable.Set[String]()
  val parts = mutable.Map[String, String]()
  val zip = new ZipInputStream(is)
  var entry = zip.getNextEntry

  while entry != null do
    if !entry.isDirectory then
      allEntries += entry.getName  // NEW: Index all entries

      if isKnownPart(entry.getName) then
        val content = new String(zip.readAllBytes(), "UTF-8")
        parts(entry.getName) = content
      // else: skip unknown part (don't load into memory)

    zip.closeEntry()
    entry = zip.getNextEntry

  for
    wb <- parseWorkbook(parts.toMap)
    context = sourcePath.map { path =>
      SourceContext.fromFile(path, allEntries.toSet, knownParts)
    }
  yield wb.copy(sourceContext = context)

private val knownParts = Set(
  "[Content_Types].xml",
  "_rels/.rels",
  "xl/workbook.xml",
  "xl/_rels/workbook.xml.rels",
  "xl/styles.xml",
  "xl/sharedStrings.xml"
  // + xl/worksheets/sheet*.xml (pattern match)
)

private def isKnownPart(path: String): Boolean =
  knownParts.contains(path) || path.matches("xl/worksheets/sheet\\d+\\.xml")
```

2. **Update public API**:

```scala
object XlsxReader:
  /** Read from file (enables passthrough) */
  def read(path: Path): XLResult[Workbook] =
    val is = Files.newInputStream(path)
    try readFromStream(is, Some(path))
    finally is.close()

  /** Read from stream (no passthrough) */
  def readFromStream(is: InputStream): XLResult[Workbook] =
    readFromStream(is, None)
```

**Key Changes**:
- ‚úÖ Index all ZIP entries (not just known 7)
- ‚úÖ Only parse known parts (memory efficient)
- ‚úÖ Create SourceContext if path provided
- ‚úÖ Backwards compatible (stream API works unchanged)

---

## Writer Enhancements

### XlsxWriter Changes

**Location**: `xl-ooxml/src/com/tjclp/xl/ooxml/XlsxWriter.scala`

**New Strategy**: Hybrid write based on modification tracking

```scala
object XlsxWriter:
  /** Write workbook to ZIP file */
  def writeZip(
    workbook: Workbook,
    outputStream: OutputStream,
    config: WriterConfig = WriterConfig.default
  ): IO[Unit] =
    workbook.sourceContext match
      case None =>
        // No source, full regeneration
        regenerateAll(workbook, outputStream, config)

      case Some(ctx) if ctx.isClean =>
        // No modifications, just copy file
        IO {
          Files.copy(ctx.sourcePath, Paths.get(outputStream.toString))
        }

      case Some(ctx) =>
        // Hybrid: regenerate modified, copy preserved
        hybridWrite(workbook, ctx, outputStream, config)

  /** Full regeneration (current behavior) */
  private def regenerateAll(
    workbook: Workbook,
    outputStream: OutputStream,
    config: WriterConfig
  ): IO[Unit] = IO {
    val zip = new ZipOutputStream(outputStream)
    // ... current implementation unchanged
  }

  /** Hybrid write: copy + regenerate */
  private def hybridWrite(
    workbook: Workbook,
    ctx: SourceContext,
    outputStream: OutputStream,
    config: WriterConfig
  ): IO[Unit] = IO.defer {
    val zip = new ZipOutputStream(outputStream)
    val tracker = ctx.modificationTracker

    // PHASE 1: Determine what to preserve vs. regenerate
    val preservableParts = determinePreservableParts(workbook, ctx)
    val regenerateParts = determineRegenerateParts(workbook, ctx)

    // PHASE 2: Write structural parts (always regenerated)
    writeStructuralParts(zip, workbook, config)

    // PHASE 3: Write sheets (hybrid)
    workbook.sheets.zipWithIndex.foreach { case (sheet, idx) =>
      if tracker.modifiedSheets.contains(idx) then
        // Modified sheet ‚Üí regenerate XML
        writeSheetXml(zip, sheet, idx, config)
      else
        // Unmodified sheet ‚Üí copy from source
        val sheetPath = s"xl/worksheets/sheet${idx + 1}.xml"
        ctx.preservedParts.copyTo(sheetPath, zip)
    }

    // PHASE 4: Copy unknown preserved parts
    preservableParts.foreach { path =>
      ctx.preservedParts.copyTo(path, zip)
    }

    IO(zip.close())
  }

  /** Determine which parts can be preserved */
  private def determinePreservableParts(
    wb: Workbook,
    ctx: SourceContext
  ): Set[String] =
    val tracker = ctx.modificationTracker
    val allPreserved = ctx.preservedParts.listAll

    // Filter out parts that depend on modified sheets
    allPreserved.filter { path =>
      // Drawings depend on sheet indices
      if path.matches("xl/drawings/drawing\\d+\\.xml") then
        val sheetIdx = extractSheetIndex(path)
        !tracker.modifiedSheets.contains(sheetIdx)

      // Charts depend on sheet data
      else if path.startsWith("xl/charts/") then
        // Conservative: preserve only if NO sheets modified
        tracker.modifiedSheets.isEmpty

      // Comments reference specific cells
      else if path.matches("xl/comments\\d+\\.xml") then
        val sheetIdx = extractSheetIndex(path)
        !tracker.modifiedSheets.contains(sheetIdx)

      // Sheet relationships depend on sheet
      else if path.matches("xl/worksheets/_rels/sheet\\d+\\.xml\\.rels") then
        val sheetIdx = extractSheetIndex(path)
        !tracker.modifiedSheets.contains(sheetIdx)

      // Other parts can be preserved
      else
        true
    }

  /** Determine which parts must be regenerated */
  private def determineRegenerateParts(
    wb: Workbook,
    ctx: SourceContext
  ): Set[String] =
    val tracker = ctx.modificationTracker
    val regenerate = mutable.Set[String]()

    // Always regenerate structural parts
    regenerate ++= Set(
      "[Content_Types].xml",
      "_rels/.rels",
      "xl/workbook.xml",
      "xl/_rels/workbook.xml.rels"
    )

    // Regenerate styles if any sheet modified (style indices may change)
    if tracker.modifiedSheets.nonEmpty then
      regenerate += "xl/styles.xml"

    // Regenerate SST if any sheet modified (string indices may change)
    if tracker.modifiedSheets.nonEmpty then
      regenerate += "xl/sharedStrings.xml"

    // Regenerate modified sheets
    tracker.modifiedSheets.foreach { idx =>
      regenerate += s"xl/worksheets/sheet${idx + 1}.xml"
    }

    regenerate.toSet
```

**Key Algorithm**:
1. **Structural parts**: Always regenerate (workbook.xml, relationships)
2. **Modified sheets**: Regenerate XML
3. **Unmodified sheets**: Copy from source if no dependencies changed
4. **Unknown parts**: Copy if they don't reference modified sheets
5. **Dependencies**: Conservative (if unsure, regenerate)

---

## Implementation Phases

### Phase 1: Foundation (Days 1-2)

**Goal**: Add domain model changes, no behavioral changes yet

**Tasks**:
1. ‚úÖ Create `xl-core/src/com/tjclp/xl/SourceContext.scala`
2. ‚úÖ Create `xl-core/src/com/tjclp/xl/ModificationTracker.scala`
3. ‚úÖ Add `sourceContext: Option[SourceContext]` to `Workbook`
4. ‚úÖ Add modification helpers to `Workbook` (`updateSheet`, `deleteSheet`, etc.)
5. ‚úÖ Write unit tests for `ModificationTracker` laws
6. ‚úÖ Write unit tests for `SourceContext` helpers

**Success Criteria**:
- All existing tests pass (no behavioral changes)
- New domain types compile and have basic tests
- Zero impact on current read/write behavior

**Test Plan**:
```scala
// ModificationTrackerSpec.scala
test("clean tracker has no modifications"):
  assert(ModificationTracker.clean.isClean)

test("marking sheet as modified makes dirty"):
  val tracker = ModificationTracker.clean.markSheet(0)
  assert(!tracker.isClean)
  assert(tracker.modifiedSheets == Set(0))

test("merging trackers combines modifications"):
  val t1 = ModificationTracker.clean.markSheet(0)
  val t2 = ModificationTracker.clean.markSheet(1)
  val merged = t1.merge(t2)
  assert(merged.modifiedSheets == Set(0, 1))

// Workbook update helpers
test("updateSheet marks sheet as modified"):
  val wb = Workbook.empty
    .copy(sourceContext = Some(SourceContext(...)))
  val updated = wb.updateSheet("Sheet1", identity).getOrElse(???)
  assert(updated.sourceContext.get.modificationTracker.modifiedSheets.nonEmpty)
```

---

### Phase 2: Lazy Preserved Parts (Days 3-4)

**Goal**: Implement lazy loading of unknown ZIP entries

**Tasks**:
1. ‚úÖ Create `xl-ooxml/src/com/tjclp/xl/ooxml/LazyPreservedParts.scala`
2. ‚úÖ Implement `LazyPreservedPartsImpl` with streaming copy
3. ‚úÖ Add unit tests for lazy loading
4. ‚úÖ Add integration tests for large preserved parts
5. ‚úÖ Add memory tests (verify no materialization)

**Success Criteria**:
- Can index 1000+ ZIP entries without memory spike
- Can copy 100MB preserved part without loading into RAM
- Tests verify streaming behavior

**Test Plan**:
```scala
// LazyPreservedPartsSpec.scala
test("indexing large ZIP doesn't materialize content"):
  val largePath = createZipWith1000Entries(eachSize = 10.MB)
  val memBefore = currentHeap()

  val preserved = LazyPreservedParts.fromPath(largePath, allEntries)
  val memAfter = currentHeap()

  assert((memAfter - memBefore) < 50.MB)  // Only index, not content

test("copyTo streams without materialization"):
  val sourcePath = createZipWithLargeEntry("xl/charts/chart1.xml", 50.MB)
  val preserved = LazyPreservedParts.fromPath(sourcePath, Set("xl/charts/chart1.xml"))

  val memBefore = currentHeap()
  val output = new ByteArrayOutputStream()
  preserved.copyTo("xl/charts/chart1.xml", new ZipOutputStream(output)).unsafeRunSync()
  val memAfter = currentHeap()

  assert((memAfter - memBefore) < 10.MB)  // Streaming, no full buffer
```

---

### Phase 3: Reader Enhancement (Days 5-6)

**Goal**: XlsxReader indexes all parts and creates SourceContext

**Tasks**:
1. ‚úÖ Update `XlsxReader.readFromStream` to index all entries
2. ‚úÖ Add `isKnownPart` predicate
3. ‚úÖ Create `SourceContext` when path provided
4. ‚úÖ Update public API (`read(path)` vs `readFromStream`)
5. ‚úÖ Add tests for unknown part preservation
6. ‚úÖ Verify memory efficiency (unknown parts not loaded)

**Success Criteria**:
- Reading file with charts/images preserves all parts
- Memory usage unchanged (unknown parts not materialized)
- Backwards compatible (stream API works)

**Test Plan**:
```scala
// XlsxReaderPassthroughSpec.scala
test("read from file creates SourceContext"):
  val path = resourcePath("workbook-with-charts.xlsx")
  val wb = XlsxReader.read(path).getOrElse(???)

  assert(wb.sourceContext.isDefined)
  assert(wb.sourceContext.get.sourcePath == path)
  assert(wb.sourceContext.get.preservedParts.exists("xl/charts/chart1.xml"))

test("read from stream does not create SourceContext"):
  val is = Files.newInputStream(resourcePath("workbook.xlsx"))
  val wb = XlsxReader.readFromStream(is).getOrElse(???)

  assert(wb.sourceContext.isEmpty)

test("unknown parts are indexed but not loaded"):
  val path = createWorkbookWith100Charts(eachSize = 5.MB)  // 500MB total
  val memBefore = currentHeap()

  val wb = XlsxReader.read(path).getOrElse(???)
  val memAfter = currentHeap()

  assert(wb.sourceContext.get.preservedParts.listAll.size == 100)
  assert((memAfter - memBefore) < 100.MB)  // Not all 500MB loaded
```

---

### Phase 4: Writer Enhancement (Days 7-8)

**Goal**: XlsxWriter uses hybrid strategy for modified workbooks

**Tasks**:
1. ‚úÖ Implement `hybridWrite` strategy
2. ‚úÖ Implement `determinePreservableParts`
3. ‚úÖ Implement `determineRegenerateParts`
4. ‚úÖ Update `writeZip` to dispatch on SourceContext
5. ‚úÖ Add tests for hybrid write
6. ‚úÖ Add tests for part preservation
7. ‚úÖ Add performance benchmarks

**Success Criteria**:
- Unmodified workbook write is fast copy (<100ms)
- Single sheet modification preserves 90%+ of file
- Modified sheets get canonical XML
- Unknown parts preserved byte-for-byte

**Test Plan**:
```scala
// XlsxWriterHybridSpec.scala
test("unmodified workbook is copied, not regenerated"):
  val source = resourcePath("workbook-with-charts.xlsx")
  val wb = XlsxReader.read(source).getOrElse(???)

  val output = tempFile()
  val timeBefore = System.currentTimeMillis()
  XlsxWriter.writeZip(wb, Files.newOutputStream(output)).unsafeRunSync()
  val duration = System.currentTimeMillis() - timeBefore

  assert(duration < 100)  // Fast copy, not full regeneration
  assert(Files.size(output) == Files.size(source))

test("modified sheet preserves unmodified parts"):
  val source = resourcePath("workbook-with-charts.xlsx")
  val wb = XlsxReader.read(source).getOrElse(???)
  val modified = wb.updateSheet("Sheet1", _.put(cell"A1", "Changed")).getOrElse(???)

  val output = tempFile()
  XlsxWriter.writeZip(modified, Files.newOutputStream(output)).unsafeRunSync()

  // Verify chart is preserved
  val zip = new ZipFile(output.toFile)
  val chartEntry = zip.getEntry("xl/charts/chart1.xml")
  assert(chartEntry != null)

  // Verify it's identical to original (byte-for-byte)
  val originalZip = new ZipFile(source.toFile)
  val originalChart = originalZip.getEntry("xl/charts/chart1.xml")
  val originalBytes = originalZip.getInputStream(originalChart).readAllBytes()
  val outputBytes = zip.getInputStream(chartEntry).readAllBytes()
  assert(java.util.Arrays.equals(originalBytes, outputBytes))

test("modified sheet gets regenerated XML"):
  val source = resourcePath("workbook.xlsx")
  val wb = XlsxReader.read(source).getOrElse(???)
  val modified = wb.updateSheet("Sheet1", _.put(cell"A1", "New Value")).getOrElse(???)

  val output = tempFile()
  XlsxWriter.writeZip(modified, Files.newOutputStream(output)).unsafeRunSync()

  // Re-read and verify value
  val reloaded = XlsxReader.read(output).getOrElse(???)
  val cell = reloaded("Sheet1").flatMap(_.cells.get(cell"A1")).getOrElse(???)
  assert(cell.value == CellValue.Text("New Value"))
```

---

### Phase 5: Integration & Edge Cases (Day 9)

**Goal**: Handle edge cases and ensure robustness

**Tasks**:
1. ‚úÖ Handle sheet deletion (invalidate dependent parts)
2. ‚úÖ Handle sheet reordering (regenerate all)
3. ‚úÖ Handle metadata changes (regenerate structural parts)
4. ‚úÖ Add validation warnings (e.g., "sheet references deleted chart")
5. ‚úÖ Add comprehensive integration tests
6. ‚úÖ Add error handling tests

**Success Criteria**:
- Sheet deletion doesn't break file
- Sheet reordering preserves data
- Clear error messages for invalid operations
- All edge cases have tests

**Test Plan**:
```scala
// EdgeCaseSpec.scala
test("deleting sheet with chart removes chart reference"):
  val wb = loadWorkbookWithChart(sheetIndex = 0)
  val modified = wb.deleteSheet("Sheet1").getOrElse(???)

  val output = tempFile()
  XlsxWriter.writeZip(modified, Files.newOutputStream(output)).unsafeRunSync()

  // Chart should NOT be in output (no orphaned references)
  val zip = new ZipFile(output.toFile)
  assert(zip.getEntry("xl/charts/chart1.xml") == null)

test("reordering sheets regenerates all sheet XML"):
  val wb = loadWorkbookWith3Sheets()
  val reordered = wb.reorderSheets(Vector("Sheet3", "Sheet1", "Sheet2")).getOrElse(???)

  val output = tempFile()
  XlsxWriter.writeZip(reordered, Files.newOutputStream(output)).unsafeRunSync()

  val reloaded = XlsxReader.read(output).getOrElse(???)
  assert(reloaded.sheets.map(_.name) == Vector("Sheet3", "Sheet1", "Sheet2"))

test("modifying all sheets regenerates everything"):
  val wb = loadWorkbookWith5Sheets()
  val modified = wb.sheets.indices.foldLeft(wb) { (acc, idx) =>
    acc.updateSheetAt(idx, _.put(cell"A1", s"Modified $idx")).getOrElse(acc)
  }

  // Should regenerate all (no hybrid benefit)
  val output = tempFile()
  val timeBefore = System.currentTimeMillis()
  XlsxWriter.writeZip(modified, Files.newOutputStream(output)).unsafeRunSync()
  val duration = System.currentTimeMillis() - timeBefore

  // Should be same speed as full regeneration (no hybrid overhead)
  assert(duration < 2000)
```

---

### Phase 6: Performance & Documentation (Day 10)

**Goal**: Optimize, benchmark, and document

**Tasks**:
1. ‚úÖ Add performance benchmarks
2. ‚úÖ Optimize hot paths (minimize allocations)
3. ‚úÖ Add memory profiling tests
4. ‚úÖ Write user documentation
5. ‚úÖ Write migration guide
6. ‚úÖ Update CLAUDE.md with new patterns

**Success Criteria**:
- Benchmarks show 2-11x speedup for partial updates
- Memory usage within 10% of current implementation
- Documentation complete and clear
- All tests pass

**Benchmarks**:
```scala
// PerformanceBenchmarkSpec.scala
test("benchmark: unmodified write"):
  val wb = loadLargeWorkbook(sheets = 10, rowsPerSheet = 10000)

  val timeBefore = System.currentTimeMillis()
  XlsxWriter.writeZip(wb, output).unsafeRunSync()
  val duration = System.currentTimeMillis() - timeBefore

  println(s"Unmodified write: ${duration}ms")
  assert(duration < 200)  // Should be <200ms (just file copy)

test("benchmark: single sheet modification"):
  val wb = loadLargeWorkbook(sheets = 10, rowsPerSheet = 10000)
  val modified = wb.updateSheet("Sheet1", _.put(cell"A1", "Changed")).getOrElse(???)

  val timeBefore = System.currentTimeMillis()
  XlsxWriter.writeZip(modified, output).unsafeRunSync()
  val duration = System.currentTimeMillis() - timeBefore

  println(s"Single sheet write: ${duration}ms")
  assert(duration < 1000)  // Should be <1s (1 sheet + copy rest)

test("benchmark: all sheets modification"):
  val wb = loadLargeWorkbook(sheets = 10, rowsPerSheet = 10000)
  val modified = wb.sheets.indices.foldLeft(wb) { (acc, idx) =>
    acc.updateSheetAt(idx, _.put(cell"A1", "Changed")).getOrElse(acc)
  }

  val timeBefore = System.currentTimeMillis()
  XlsxWriter.writeZip(modified, output).unsafeRunSync()
  val duration = System.currentTimeMillis() - timeBefore

  println(s"All sheets write: ${duration}ms")
  // Should be similar to current full regeneration (no hybrid benefit)
```

---

## Test Strategy

### Unit Tests (Per Phase)

**ModificationTracker** (20 tests):
- ‚úÖ Clean state invariants
- ‚úÖ Marking sheets as modified
- ‚úÖ Marking sheets as deleted
- ‚úÖ Merging trackers
- ‚úÖ Edge cases (negative indices, duplicates)

**SourceContext** (15 tests):
- ‚úÖ Creation from file
- ‚úÖ Modification tracking propagation
- ‚úÖ Clean state detection
- ‚úÖ Immutability

**LazyPreservedParts** (25 tests):
- ‚úÖ Lazy loading (no materialization)
- ‚úÖ Streaming copy
- ‚úÖ Memory efficiency
- ‚úÖ Error handling (missing entries)
- ‚úÖ Large file handling (100MB+ entries)

**XlsxReader** (30 tests):
- ‚úÖ Index all ZIP entries
- ‚úÖ Parse only known parts
- ‚úÖ Create SourceContext
- ‚úÖ Backwards compatibility
- ‚úÖ Memory efficiency
- ‚úÖ Unknown part preservation

**XlsxWriter** (40 tests):
- ‚úÖ Hybrid write strategy
- ‚úÖ Part preservation
- ‚úÖ Part regeneration
- ‚úÖ Dependency tracking
- ‚úÖ Edge cases (deletion, reordering)
- ‚úÖ Performance characteristics

**Total**: ~130 new tests

---

### Integration Tests

**Round-Trip Tests** (20 tests):
```scala
test("round-trip with charts preserves charts"):
  val original = resourcePath("workbook-with-charts.xlsx")
  val wb = XlsxReader.read(original).getOrElse(???)
  val modified = wb.updateSheet("Sheet1", _.put(cell"A1", "Changed")).getOrElse(???)

  val output = tempFile()
  XlsxWriter.writeZip(modified, Files.newOutputStream(output)).unsafeRunSync()

  val reloaded = XlsxReader.read(output).getOrElse(???)
  assert(reloaded.sourceContext.get.preservedParts.exists("xl/charts/chart1.xml"))

test("round-trip with images preserves images"):
  val original = resourcePath("workbook-with-images.xlsx")
  // ... similar to charts test

test("round-trip with comments preserves comments"):
  // ... similar to charts test

test("round-trip with pivot tables preserves pivots"):
  // ... similar to charts test
```

---

### Property-Based Tests

**Modification Tracking Laws**:
```scala
property("modification tracking is monotonic"):
  forAll { (tracker: ModificationTracker, index: Int) =>
    val modified = tracker.markSheet(index)
    assert(!modified.isClean || tracker.isClean)
  }

property("merging is associative"):
  forAll { (t1: ModificationTracker, t2: ModificationTracker, t3: ModificationTracker) =>
    assert((t1.merge(t2)).merge(t3) == t1.merge(t2.merge(t3)))
  }
```

---

### Performance Tests

**Memory Tests**:
```scala
test("reading 1000-part workbook uses <100MB"):
  val workbook = createWorkbookWith1000Charts()  // 5GB uncompressed
  val memBefore = currentHeap()

  val wb = XlsxReader.read(workbook).getOrElse(???)
  val memAfter = currentHeap()

  assert((memAfter - memBefore) < 100.MB)

test("writing unmodified workbook uses <50MB"):
  val wb = loadLargeWorkbook()
  val memBefore = currentHeap()

  XlsxWriter.writeZip(wb, output).unsafeRunSync()
  val memAfter = currentHeap()

  assert((memAfter - memBefore) < 50.MB)
```

**Speed Tests**:
```scala
test("unmodified write is 10x faster than regeneration"):
  val wb = loadLargeWorkbook()

  // Measure copy speed
  val copyTime = measureTime {
    XlsxWriter.writeZip(wb, output).unsafeRunSync()
  }

  // Measure regeneration speed (force full regeneration)
  val wb2 = wb.copy(sourceContext = None)
  val regenTime = measureTime {
    XlsxWriter.writeZip(wb2, output2).unsafeRunSync()
  }

  assert(regenTime > copyTime * 5)  // At least 5x faster
```

---

## Edge Cases & Constraints

### Edge Case 1: Sheet Deletion

**Problem**: Deleting a sheet may break references in charts/drawings

**Solution**: Conservative invalidation
```scala
def determinePreservableParts(...): Set[String] =
  if tracker.deletedSheets.nonEmpty then
    // Conservative: drop all parts that might reference sheets
    allPreserved -- Set(
      "xl/charts/*",
      "xl/drawings/*",
      "xl/comments*"
    )
  else
    // ... normal preservation logic
```

**Trade-off**: May drop more than necessary, but ensures correctness

---

### Edge Case 2: Sheet Reordering

**Problem**: Sheet order changes invalidate indices in relationships

**Solution**: Regenerate all on reorder
```scala
def hybridWrite(...): IO[Unit] =
  if ctx.modificationTracker.reorderedSheets then
    // Reordering requires full regeneration
    regenerateAll(workbook, outputStream, config)
  else
    // ... normal hybrid strategy
```

**Trade-off**: No hybrid benefit for reordering, but ensures correctness

---

### Edge Case 3: Relationship References

**Problem**: Preserved parts may have rId references that break

**Example**:
```xml
<!-- xl/drawings/drawing1.xml -->
<xdr:twoCellAnchor>
  <!-- References "Sheet1" implicitly via position -->
</xdr:twoCellAnchor>
```

**Solution**: Track relationship dependencies
```scala
// Phase 4 enhancement
case class RelationshipGraph(
  dependencies: Map[String, Set[Int]]  // part ‚Üí sheet indices
)

def buildRelationshipGraph(sourcePath: Path): RelationshipGraph =
  // Parse xl/_rels/workbook.xml.rels
  // Parse xl/worksheets/_rels/sheet*.xml.rels
  // Build dependency graph
  ???

def determinePreservableParts(...): Set[String] =
  val graph = buildRelationshipGraph(ctx.sourcePath)
  allPreserved.filter { part =>
    graph.dependencies.get(part) match
      case None => true  // No dependencies, safe
      case Some(sheetIndices) =>
        // Safe if no referenced sheets modified
        !sheetIndices.exists(tracker.modifiedSheets.contains)
  }
```

**Trade-off**: More complex, but maximally preserves parts

---

### Edge Case 4: Streaming Incompatibility

**Problem**: Passthrough requires random access to source ZIP (not streaming)

**Solution**: Detect and fail gracefully
```scala
def writeStreamTrue(...): Stream[F, Byte] =
  workbook.sourceContext match
    case Some(ctx) if !ctx.isClean =>
      // Can't stream with modifications + passthrough
      Stream.raiseError(
        XLError.InvalidOperation(
          "Streaming write incompatible with surgical modification. " +
          "Use write() instead or create fresh workbook."
        )
      )
    case _ =>
      // Normal streaming
      ...
```

**Trade-off**: Streaming and passthrough are mutually exclusive

---

### Edge Case 5: Large Preserved Parts

**Problem**: 100MB+ chart files may exhaust memory during copy

**Solution**: Stream with chunking
```scala
def copyTo(path: String, output: ZipOutputStream): IO[Unit] =
  Resource.make(IO(new ZipFile(sourcePath.toFile)))(zf => IO(zf.close())).use { zip =>
    IO {
      val entry = zip.getEntry(path)
      val is = zip.getInputStream(entry)

      output.putNextEntry(new ZipEntry(path))

      // Stream in 8KB chunks (don't buffer entire file)
      val buffer = new Array[Byte](8192)
      var bytesRead = is.read(buffer)
      while bytesRead != -1 do
        output.write(buffer, 0, bytesRead)
        bytesRead = is.read(buffer)

      is.close()
      output.closeEntry()
    }
  }
```

**Trade-off**: Slightly slower due to chunking, but constant memory

---

## Performance Analysis

### Theoretical Speedup

| Scenario | Current | With Passthrough | Speedup |
|----------|---------|------------------|---------|
| **No modifications** | 1.1s | 0.1s | **11x** |
| **1 sheet modified (of 10)** | 1.1s | 0.5s | **2.2x** |
| **5 sheets modified (of 10)** | 1.1s | 0.8s | **1.4x** |
| **All sheets modified** | 1.1s | 1.2s | **0.9x** (overhead) |

**Conclusion**: Massive speedup for partial updates, minimal overhead for full updates

---

### Memory Profile

| Operation | Current | With Passthrough | Delta |
|-----------|---------|------------------|-------|
| **Read 100-part workbook** | 80MB | 85MB | +5MB (part index) |
| **Write unmodified** | 100MB | 50MB | **-50MB** (no materialization) |
| **Write 1 sheet modified** | 100MB | 70MB | **-30MB** (partial regeneration) |

**Conclusion**: Memory improvement for writes, minimal overhead for reads

---

### Disk I/O

| Operation | Current | With Passthrough | Delta |
|-----------|---------|------------------|-------|
| **Read** | 1x parse all | 1x parse known, 1x index all | +10% (index overhead) |
| **Write (unmodified)** | 1x write all | 1x copy file | **-90%** (file copy) |
| **Write (1 sheet)** | 1x write all | 0.1x regenerate + 0.9x copy | **-50%** (hybrid) |

**Conclusion**: Significant I/O reduction for partial updates

---

## Migration Path

### For Existing Code

**No changes required!** Existing code continues to work:

```scala
// This code works unchanged:
val wb = ExcelIO.instance.read[IO](path)
val modified = wb.flatMap(_.updateSheet("Sheet1", _.put(cell"A1", "Value")))
ExcelIO.instance.write[IO](modified, output)

// Passthrough happens automatically:
// - If read from file ‚Üí sourceContext populated ‚Üí hybrid write
// - If created programmatically ‚Üí sourceContext = None ‚Üí full regeneration
```

### To Opt-In to Passthrough

**Option 1**: Use file-based API (automatic)
```scala
// Automatically gets passthrough
val wb = ExcelIO.instance.read[IO](path)
```

**Option 2**: Explicitly attach source (advanced)
```scala
// Stream API + manual source attachment
val wb = XlsxReader.readFromStream(inputStream)
val withSource = wb.map { w =>
  // Manually attach source if you have the original file
  w.copy(sourceContext = Some(SourceContext.fromFile(originalPath, ...)))
}
```

### To Opt-Out of Passthrough

```scala
// Remove source context (forces full regeneration)
val wb = loadWorkbook()
val withoutPassthrough = wb.copy(sourceContext = None)

// Or use fresh API
val fresh = Workbook.empty  // No source context
```

---

## API Documentation

### User-Facing API

**Reading**:
```scala
import com.tjclp.xl.io.ExcelIO

// Read from file (enables passthrough)
val excel = ExcelIO.instance
val workbook: IO[XLResult[Workbook]] = excel.read[IO](path)

// Read from stream (no passthrough)
val workbook: IO[XLResult[Workbook]] = excel.readFromStream[IO](inputStream)
```

**Modification**:
```scala
// All modifications automatically tracked
val updated = for
  wb <- workbook
  wb <- wb.updateSheet("Sales", sheet =>
    sheet
      .put(cell"A1", "New Value")
      .put(cell"B1", 42)
  )
yield wb

// Check if modified
val hasChanges = wb.sourceContext.exists(!_.isClean)
```

**Writing**:
```scala
// Write with automatic passthrough
excel.write[IO](updated, outputPath)

// Hybrid write happens automatically:
// - Unmodified ‚Üí fast copy
// - Partially modified ‚Üí regenerate changed parts only
// - Fully modified ‚Üí full regeneration
```

### Internal API (For Advanced Users)

**SourceContext Access**:
```scala
// Check source information
workbook.sourceContext match
  case None =>
    println("Workbook created programmatically")
  case Some(ctx) =>
    println(s"Source: ${ctx.sourcePath}")
    println(s"Modified sheets: ${ctx.modificationTracker.modifiedSheets}")
    println(s"Preserved parts: ${ctx.preservedParts.listAll.size}")
```

**Manual Modification Tracking**:
```scala
// Advanced: manually mark sheets
val wb = workbook.copy(
  sourceContext = workbook.sourceContext.map(_.markSheetModified(0))
)
```

---

## Future Extensions

### Phase 7+: Incremental Feature Parsing

Once passthrough is working, we can incrementally add feature-specific parsing:

**P7.1: Comments**:
```scala
case class SourceContext(
  ...,
  parsedComments: Option[Map[Int, Comments]] = None  // NEW
)

// Users opt-in to comment parsing
val wb = ExcelIO.instance.readWithComments[IO](path)
wb.flatMap { w =>
  w.sourceContext.get.parsedComments.get(0)  // Access sheet 0 comments
}
```

**P7.2: Hyperlinks**:
```scala
case class SourceContext(
  ...,
  parsedHyperlinks: Option[Map[Int, Hyperlinks]] = None  // NEW
)
```

**P7.3: Named Ranges**:
```scala
case class Workbook(
  ...,
  namedRanges: Vector[NamedRange] = Vector.empty  // NEW
)
```

**Architecture Benefit**: Each feature is opt-in, incremental, and doesn't break existing code.

---

## Summary

### What We're Building

A foundational architecture that:
1. ‚úÖ Preserves ALL unknown OOXML features (charts, images, comments, etc.)
2. ‚úÖ Tracks modifications at sheet-level granularity
3. ‚úÖ Only regenerates modified parts (2-11x speedup)
4. ‚úÖ Memory efficient (lazy loading, no materialization)
5. ‚úÖ Type-safe and pure (immutable tracking)
6. ‚úÖ Non-breaking (existing code works unchanged)

### Why This Matters

**For Users**:
- üéØ Zero data loss on round-trips
- üöÄ Dramatically faster writes for partial updates
- üíæ Lower memory usage
- ‚úÖ Confidence that "unknown" features are preserved

**For XL**:
- üèóÔ∏è Foundation for all future OOXML features
- üìà Incremental path to full OOXML parity
- üîÆ Differentiator: No other library does this
- üé® Maintains purity and type safety

### Implementation Confidence

**Low Risk**:
- Purely additive (no breaking changes)
- Extensive test coverage (130+ new tests)
- Phased rollout (6 phases, each testable)
- Backwards compatible (existing code works)

**High Reward**:
- Immediate user value (preserve unknown features)
- Long-term architectural foundation
- Performance improvements (2-11x speedup)
- Market differentiation (unique capability)

---

## Next Steps

1. ‚úÖ Review and approve this design
2. ‚úÖ Create implementation branch: `feat/surgical-modification`
3. ‚úÖ Implement Phase 1: Foundation (Days 1-2)
4. ‚úÖ Implement Phase 2: Lazy Preserved Parts (Days 3-4)
5. ‚úÖ Implement Phase 3: Reader Enhancement (Days 5-6)
6. ‚úÖ Implement Phase 4: Writer Enhancement (Days 7-8)
7. ‚úÖ Implement Phase 5: Integration & Edge Cases (Day 9)
8. ‚úÖ Implement Phase 6: Performance & Documentation (Day 10)
9. ‚úÖ Create PR with comprehensive tests
10. ‚úÖ Merge to main and update roadmap

**Estimated Total Effort**: 8-10 days
**Priority**: HIGHEST (blocks all future OOXML features)
**Status**: Ready for implementation

---

_This design is complete and ready for implementation. All architectural decisions are documented, all edge cases are considered, and all tests are specified. This is the foundation for XL's future._
